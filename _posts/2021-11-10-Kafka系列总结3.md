---
layout:     post
title:      Kafka系列总结3
subtitle:   Kafka基础知识
date:       2021-11-10
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - kafka

---


# Kafka系列总结3

Kafka基础知识
--

## 基本简介

kafka主要使用场景

数据收集：通过收集日志数据，用户活动数据，会通过kafka进行汇总，传递到hadoop或者其他数据分析工具中，进行分析和挖掘。

系统解耦：解耦生产者和消费者、进行流量削峰和性能提升。
## 基本概念

Broker：消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群。

Topic：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic。

Producer：消息生产者，向Broker发送消息的客户端。

Consumer：消息消费者，从Broker读取消息的客户端。

ConsumerGroup：每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer Group消费，但是一个Consumer Group中只能有一个Consumer能够消费该消息。

Partition：物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的。

![picture1](/img/kafka/architecture.png)

## 消息存储

对于每一个Topic，有多个分区partition，Partition是一个有序的message序列，这些message按顺序添加到一个叫做commit log的文件中。每个partition中的消息都有一个唯一的编号，称之为offset，用来唯一标示某个分区中的message。 

每个partition，都对应一个commit log文件。一个partition中的message的offset都是唯一的，但是不同的partition中的message的offset可能是相同的。

kafka一般不会删除消息，不管这些消息有没有被消费。只会根据配置的日志保留时间(log.retention.hours)确认消息多久被删除，默认保留最近一周的日志消息。kafka的性能与保留的消息数据量大小没有关系，因此保存大量的数据消息日志信息不会有什么影响。

每个consumer是基于自己在commit log中的消费进度(offset)来进行工作的。在kafka中，消费offset由consumer自己来维护；一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息，或者跳过某些消息。

这意味kafka中的consumer对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer来说，都是没有影响的，因为每个consumer维护各自的消费offset。

![picture2](/img/kafka/topic.png)

## kafka集群

log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。kafka集群支持配置一个partition备份的数量。

针对每个partition，都有一个broker起到“leader”的作用，0个或多个其他的broker作为“follwers”的作用。leader处理所有的针对这个partition的读写请求，而followers被动复制leader的结果，不提供读写(主要是为了保证多副本数据与消费的一致性)。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。

**Producers**

生产者将消息发送到topic中去，同时负责选择将message发送到topic的哪一个partition中。通过round-robin做简单的负载均衡。也可以根据消息中的某一个关键字来进行区分。通常第二种方式使用的更多。

**Consumers**

传统的消息传递模式有2种：队列( queue) 和（publish-subscribe）

- queue模式：多个consumer从服务器中读取数据，消息只会到达一个consumer。
- publish-subscribe模式：消息会被广播给所有的consumer。

Kafka基于这2种模式提供了一种consumer的抽象概念：consumer group。

- queue模式：所有的consumer都位于同一个consumer group 下。
- publish-subscribe模式：所有的consumer都有着自己唯一的consumer group。

![picture2](/img/kafka/cluster.png)

**消费顺序**

一个partition同一个时刻在一个consumer group中只能有一个consumer在消费，从而保证消费顺序。

consumer group中的consumer instance的数量不会比一个Topic中的partition的数量多，否则，多出来的consumer消费不到消息。

Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。

如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer instance数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。


参考文献
--