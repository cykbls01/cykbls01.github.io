---
layout:     post
title:      RabbitMq系列总结3
subtitle:   RabbitMq基础知识
date:       2021-11-11
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - rabbitmq

---


# RabbitMq系列总结3

RabbitMq基础知识
--

## 基本简介

2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。

## 基本概念

Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker。

Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等。

Connection：publisher／consumer 和 broker 之间的 TCP 连接。

Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。

Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。

Queue：消息最终被送到这里等待 consumer 取走。

Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。

![picture1](/img/rabbitmq/architecture.png)

## 工作模式

### 简单模式

P：生产者，也就是要发送消息的程序。

C：消费者：消息的接收者，会一直等待消息到来。

queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。

![picture1](/img/rabbitmq/simple.png)

### 工作队列模式

相比简单模式，增加了一些消费者，用于消息生产繁重的系统。在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。

![picture1](/img/rabbitmq/workqueue.png)

在接下来的三种模式中，多了一个 Exchange 角色，而且过程略有变化：

P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）。

C：消费者，消息的接收者，会一直等待消息到来。

Queue：消息队列，接收消息、缓存消息。

Exchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。Exchange只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失。

### 广播模式

广播模式采用direct的交换机类型，向所有与交换机绑定的队列发送消息。

![picture1](/img/rabbitmq/fanout.png)

### 路由模式

路由模式采用fanout的交换机类型，向所有与交换机绑定并且包含相同消息key的队列发送消息。

![picture1](/img/rabbitmq/direct.png)

### 主题模式

主题模式采用topic的交换机类型，向所有与交换机绑定并且与key能够匹配的队列发送消息。其中'#'代表随意几个单词，'*'代表一个单词。

![picture1](/img/rabbitmq/topic.png)

## 相关特性
### 消息confirm与return

RabbitMq可以使用listener来监听发送消息的状态，其中confirm表示消息是否达到broker，如果没到就会回退。return则是当broker无法找到队列进行投递时，会将消息回退。

### 消费端限流

当消费者处理速度跟不上的时候，要在消费端进行流量控制。在<rabbit:listener-container> 中配置 prefetch属性设置消费端一次拉取多少消息。消费端的确认模式一定为手动确认。acknowledge="manual"。

### TTL

TTL 全称 Time To Live（存活时间/过期时间）。当消息到达存活时间后，还没有被消费，会被自动清除。RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。

设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。如果两者都进行了设置，以时间短的为准。

### 死信队列

死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。当队列消息长度到达限制，或者消费者拒接消费消息，并且不把消息重新放入原目标队列。以及原队列存在消息过期设置，消息到达超时时间未被消费。这些情况会产生死信队列。给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key可以绑定死信交换机。

### 延迟队列

延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。RabbitMq不支持延迟队列，只有TTL+死信队列组合实现延迟队列的效果。


参考文献
--

图灵学院java架构课程