---
layout:     post
title:      RabbitMq系列总结4
subtitle:   RabbitMq进阶知识
date:       2021-11-11
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - rabbitmq

---


# RabbitMq系列总结4

RabbitMq进阶知识
--

## 消息存储

RabbitMQ消息有两种类型:持久化消息和非持久化消息，这两种消息都会被写入磁盘。

持久化消息在到达队列时写入磁盘，同时会内存中保存一份备份，当内存吃紧时，消息从内存中清除。这会提高一定的性能。 非持久化消息一般只存于内存中，当内存压力大时数据刷盘处理，以节省内存空间。 RabbitMQ存储层包含两个部分:队列索引和消息存储。

### 队列索引

索引维护队列的落盘消息的信息，如存储地点、是否已被给消费者接收、是否已被消费者ack等。 每个队列都有相对应的索引。索引数据文件位置如下，索引使用顺序的段文件来存储，后缀为.idx，文件名从0开始累加，每个段文件中包含固定的 segment_entry_count 条记录，默认值是16384。每个index从磁盘中读取消息的时候，至少要在内存中维护一个段文件，所以设置 queue_index_embed_msgs_below 值得时候要格外谨慎，一点点增大也 可能会引起内存爆炸式增长。

### 消息存放

消息以键值对的形式存储到文件中，一个虚拟主机上的所有队列使用同一块存储，每个节点只有一 个。存储分为持久化存储(msg_store_persistent)和短暂存储(msg_store_transient)。持久化存储的内容在broker重启后不会丢失，短暂存储的内容在broker重启后丢失。

消息(包括消息头、消息体、属性)可以直接存储在index中，也可以存储在store中。最佳的方式 是较小的消息存在index中，而较大的消息存在store中。这个消息大小的界定可以通过queue_index_embed_msgs_below 来配置，默认值为4096B。当一个消息小于设定的大小阈值时，就可以存储在index中，这样性能上可以得到优化。一个完整的消息大小小于这个值，就放到索引中，否则放到持久化消息文件中。

读取消息时，先根据消息的ID(msg_id)找到对应存储的文件，如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息内容。如果文件不存在或者被锁住了，则发送请求由store进行处理。

删除消息时，只是从ETS表删除指定消息的相关信息，同时更新消息对应的存储文件和相关信息。 在执行消息删除操作时，并不立即对文件中的消息进行删除，也就是说消息依然在文件中，仅仅是标记 为垃圾数据而已。当一个文件中都是垃圾数据时可以将这个文件删除。当检测到前后两个文件中的有效 数据可以合并成一个文件，并且所有的垃圾数据的大小和所有文件(至少有3个文件存在的情况下)的 数据大小的比值超过设置的阈值garbage_fraction(默认值0.5)时，才会触发垃圾回收，将这两个文件 合并，执行合并的两个文件一定是逻辑上相邻的两个文件。合并流程:

锁定这两个文件，先整理前面的文件的有效数据，再整理后面的文件的有效数据。将后面文件的有效数据写入到前面的文件中。更新消息在ETS表中的记录。删除后面文件

### 队列结构

通常队列由rabbit_amqqueue_process和backing_queue这两部分组成， rabbit_amqqueue_process负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消 息、处理消息的确认(包括生产端的confirm和消费端的ack)等。backing_queue是消息存储的具体形式和引擎，并向rabbit_amqqueue_process提供相关的接口以供调用。

关于消息堆积后的性能下降，在系统负载较高时，消息若不能很快被消费掉，这些消息就会进入到很深的队列中去，这样会增加 处理每个消息的平均开销。因为要花更多的时间和资源处理“堆积”的消息，如此用来处理新流入的消息 的能力就会降低，使得后流入的消息又被积压到很深的队列中，继续增大处理每个消息的平均开销，继 而情况变得越来越恶化，使得系统的处理能力大大降低。因此提高消费者的消费速度或者限制发送端的流量是解决方法。

## 集群模式

RabbitMQ的集群节点包括内存节点、磁盘节点。顾名思义内存节点就是将所有数据放在内存，磁盘节点将数据放在磁盘。不过，如果在投递消息时，打开了消息的持久化，那么即使是内存节点，数据还是安全的放在磁盘。

一个rabbitmq集群中可以共享 user，vhost，queue，exchange等，所有的数据和状态都是必须在所有节点上复制的，一个例外是，那些当前只属于创建它的节点的消息队列，尽管它们可见且可被所有节点读取。rabbitmq节点可以动态的加入到集群中，一个节点它可以加入到集群中，也可以从集群环境中移除。

内存节点虽然不写入磁盘，但是它执行比磁盘节点要好。集群中，只需要一个磁盘节点来保存状态 就足够了如果集群中只有内存节点，那么不能停止它们，否则所有的状态，消息等都会丢失。

良好的设计架构可以如下：在一个集群里，有3台以上机器，其中1台使用磁盘模式，其它使用内存模式。其它几台为内存模式的节点，无疑速度更快，因此客户端（consumer、producer）连接访问它们。而磁盘模式的节点，由于磁盘IO相对较慢，因此仅作数据备份使用。

### 普通模式

默认的集群模式，queue创建之后，如果没有其它policy，则queue就会按照普通模式集群。对于Queue来说，消息实体只存在于其中一个节点，A、B两个节点仅有相同的元数据，即队列结构，但队列的元数据仅保存有一份，即创建该队列的rabbitmq节点（A节点），当A节点宕机，你可以去其B节点查看发现该队列已经丢失，但声明的exchange还存在。当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer，所以consumer应平均连接每一个节点，从中取消息。该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。如果做了队列持久化或消息持久化，那么得等A节点恢复，然后才可被消费，并且在A节点恢复之前其它节点不能再创建A节点已经创建过的持久队列；如果没有持久化的话，消息就会失丢。这种模式更适合非持久化队列，只有该队列是非持久的，客户端才能重新连接到集群里的其他节点，并重新创建队列。假如该队列是持久化的，那么唯一办法是将故障节点恢复起来。


### 镜像模式

该模式解决了上述问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。

## 消息流程

### 发送消息

- 生产者连接到Broker 建立一个连接，然后开启一个信道
- 接着生产者声明一个交换器 ，并设置相关属性，比如交换机类型、是否持久化、是否自动删除、是否内置等
- 生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除、消息最大过期时间、消息最大长度、消息最大字节数等
- 生产者通过路由键将交换器和队列绑定起来
- 生产者发送消息至Broker ，发送的消息包含消息体和含有路由键、交换器、优先级、是否持久化、过期时间、延时时间等信息的标签
- 相应的交换器根据接收到的路由键查找相匹配的队列如果找到 ，则将从生产者发送过来的消息存入相应的队列中
- 如果没有找到 ，则根据生产者配置的属性选择丢弃还是回退给生产者
- 关闭信道
- 关闭连接

### 接收消息

- 消费者连接到Broker ，建立一个连接，开启一个信道
- 消费者向 RabbitMQ Broker 请求消费相应队列中的消息，在这个过程中可能会设置消费者标签、是否自动确认、是否排他等
- 等待 RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息。
- 消费者确认接收到的消息
- RabbitMQ从队列中删除相应己经被确认的消息
- 关闭信道
- 关闭连接。

参考文献
--

图灵学院java架构课程

[RabbitMQ消息传递流程](https://cloud.tencent.com/developer/article/1453456)

[RabbitMQ两种集群模式配置管理](https://www.daimajiaoliu.com/daima/479f950ab100406)

[RabbitMQ存储模型](https://www.codenong.com/cs106881045/)