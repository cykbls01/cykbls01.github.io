---
layout:     post
title:      Rabbitmq系列总结2
subtitle:   RabbitMq Demo
date:       2021-11-10
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - rabbitmq
    - java

---


# Rabbitmq系列总结2

RabbitMq Demo
--

主要是介绍一下消费者和生产者的各类api以及配置，由maven进行简单配置。

---

## Maven配置

```java
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.3.0</version>
</dependency>
```

## 建立连接
```java
    private static ConnectionFactory connectionFactory = new ConnectionFactory();
    static {
        connectionFactory.setHost("192.168.2.11");
        connectionFactory.setPort(5672);//5672是RabbitMQ的默认端口号
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        connectionFactory.setVirtualHost("test");
    }
    public static Connection getConnection(){
        Connection conn = null;
        try {
            conn = connectionFactory.newConnection();
            return conn;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
```
## 生产者实现

生产者的配置以及具体发送代码如下。包括了五种模式的实现，其中要注意的是，后三种模式不需要声明队列，实际上是消费者在消费的时候，根据key来使queue接入不同exchange。

```java
        Connection conn = RabbitUtils.getConnection();
        Channel channel = conn.createChannel();//获取长连接，创建通道

        /*
        //创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列
        //第一个参数：队列名称ID
        //第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失
        //第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问
        //第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列
        //其他额外的参数, null
        channel.queueDeclare("queue_name", false, false, false, null);

        for(int i = 1 ; i <= 100 ; i++) {
            String message = "hello" + i;
            channel.basicPublish("" , "queue_name" , null , message.getBytes());
        }
        *///简单模式，工作队列模式实现

        /*
        Map area = new LinkedHashMap<String, String>();
        area.put("test.message.20201127", "测试消息1");
        area.put("test.message.20201128", "测试消息1");
        area.put("test.message1.20201127", "测试消息1");
        area.put("test.message1.20201128", "测试消息1");

        Iterator<Map.Entry<String, String>> itr = area.entrySet().iterator();
        while (itr.hasNext()) {
            Map.Entry<String, String> me = itr.next();
            //第一个参数交换机名字   第二个参数作为 消息的routing key
            channel.basicPublish("exchange_name",me.getKey() , null , me.getValue().getBytes());

        }
        *///发布订阅模式，routing模式，topic模式实现
        
        channel.close();
        conn.close();//关闭通道以及连接
```

## 消费者实现

消费者的配置以及具体发送代码如下。

```java
        Connection conn = RabbitUtils.getConnection();
        Channel channel = conn.createChannel();//获取长连接，创建通道

        //创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列
        //第一个参数：队列名称ID
        //第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失
        //第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问
        //第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列
        //其他额外的参数, null
        channel.queueDeclare("queue_name",false, false, false, null);

        /*
        channel.basicQos(1);//简单模式不需要这一行，主要是为了让消费者一次取一条，如果不写会由rabbit平均分配消息
        //创建一个消息消费者
        //第一个参数：队列名
        //第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法
        //第三个参数要传入DefaultConsumer的实现类
        channel.basicConsume("queue_name" , false , new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String message = new String(body);
                System.out.println("message");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                channel.basicAck(envelope.getDeliveryTag() , false);//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息
            }
        });
        *///简单模式，工作队列模式实现

        /*
        
        channel.queueBind("queue_name", "exchange_name", "key");
        //key为空，代表广播模式
        //key全写，代表routing模式
        //key使用通配符，代表topic模式
        
        channel.basicQos(1);//配置该行主要是为了让消费者一次取一条，如果不写会由rabbit平均分配消息
        //创建一个消息消费者
        //第一个参数：队列名
        //第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法
        //第三个参数要传入DefaultConsumer的实现类
        channel.basicConsume("queue_name" , false , new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String message = new String(body);
                System.out.println(message);
                channel.basicAck(envelope.getDeliveryTag() , false);//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息
            }
        });
        *///发布订阅模式，routing模式，topic模式实现

```
## 消息确认机制
```java
        Connection connection = RabbitUtils.getConnection();
        Channel channel = connection.createChannel();
        //开启confirm监听模式
        channel.confirmSelect();
        channel.addConfirmListener(new ConfirmListener() {
            public void handleAck(long l, boolean b) throws IOException {
                //第二个参数代表接收的数据是否为批量接收，一般我们用不到。
                System.out.println("消息已被Broker接收,Tag:" + l );
            }

            public void handleNack(long l, boolean b) throws IOException {
                System.out.println("消息已被Broker拒收,Tag:" + l);
            }
        });//confirm模式是broker无法接受消息，消息退回
       //开启return监听模式
       channel.addReturnListener(new ReturnCallback() {
            public void handle(Return r) {
                System.err.println("===========================");
                System.err.println("Return编码：" + r.getReplyCode() + "-Return描述:" + r.getReplyText());
                System.err.println("交换机:" + r.getExchange() + "-路由key:" + r.getRoutingKey() );
                System.err.println("Return主题：" + new String(r.getBody()));
                System.err.println("===========================");
            }
        });//return模式是broker正常接受了消息，但是没有exchange或者队列进行投递，消息退回
        // 不能关闭队列，否则就没法监听了
```

参考文献
--