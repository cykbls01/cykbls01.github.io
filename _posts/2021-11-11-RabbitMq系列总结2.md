---
layout:     post
title:      RabbitMq系列总结2
subtitle:   RabbitMq Demo
date:       2021-11-10
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - rabbitmq
    - java

---


# RabbitMq系列总结2

RabbitMq 使用教程
--

主要介绍rabbitmq各种工作模式的使用方式，源码地址。

---

## Maven配置

```java
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.3.0</version>
</dependency>
```

## 建立连接
```java
    private static ConnectionFactory connectionFactory = new ConnectionFactory();
    static {
        connectionFactory.setHost("192.168.2.11");
        connectionFactory.setPort(5672);//5672是RabbitMQ的默认端口号
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        connectionFactory.setVirtualHost("test");
    }
    public static Connection getConnection(){
        Connection conn = null;
        try {
            conn = connectionFactory.newConnection();
            return conn;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
```
## 工作模式

关于启动顺序，请优先启动带有队列声明的代码，之所以把队列声明不放在一个地方，主要是为了体会队列声明谁都可以进行，但是如果不先声明队列，消息无法直接或者从exchange到达。

同时请在rabbit管理界面优先创建三种对应模式的exchange。

### 单消费者模式
```java
public static void main(String[] args) throws IOException, TimeoutException {

        //获取TCP长连接
        Connection conn = Connect.getConnection();
        //创建通信“通道”，相当于TCP中的虚拟连接
        Channel channel = conn.createChannel();

        //创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列
        //第一个参数：队列名称ID
        //第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失
        //第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问
        //第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列
        //其他额外的参数, null
        channel.queueDeclare("simple",false, false, false, null);

        String message = "hello world";

        //四个参数
        //exchange 交换机，暂时用不到，在后面进行发布订阅时才会用到
        //队列名称
        //额外的设置属性
        //最后一个参数是要传递的消息字节数组
        channel.basicPublish("", "simple", null,message.getBytes());
        channel.close();
        conn.close();
        System.out.println("===发送成功===");
}
```
```java
public static void main(String[] args) throws IOException, TimeoutException {

        //获取TCP长连接
        Connection conn = Connect.getConnection();
        //创建通信“通道”，相当于TCP中的虚拟连接
        Channel channel = conn.createChannel();

        //创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列
        //第一个参数：队列名称ID
        //第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失
        //第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问
        //第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列
        //其他额外的参数, null
        channel.queueDeclare("simple",false, false, false, null);

        //从MQ服务器中获取数据
        //创建一个消息消费者
        //第一个参数：队列名
        //第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法
        //第三个参数要传入DefaultConsumer的实现类
        channel.basicConsume("simple", false, new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("queue:" + new String(body));
                channel.basicAck(envelope.getDeliveryTag() , false);
            }
        });
}
```

### 多消费者模式
```java
public static void main(String[] args) throws IOException, TimeoutException {

        Connection connection = Connect.getConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare("multiple", false, false, false, null);

        int i = 0;
        while(true){
            i++;
            String message = "multiple" + i;
            channel.basicPublish("" , "multiple" , null , message.getBytes());
            if(i > 20){
                break;
            }
        }

        channel.close();
        connection.close();
        System.out.println("发送数据成功");
}
```
```java
public static void main(String[] args) throws IOException {

        Thread t1 = new Thread(() -> {
            try {
                Connection connection = Connect.getConnection();
                final Channel channel = connection.createChannel();

                //如果不写basicQos（1），则自动MQ会将所有请求平均发送给所有消费者
                //basicQos,MQ不再对消费者一次发送多个请求，而是消费者处理完一个消息后（确认后），在从队列中获取一个新的
                channel.basicQos(1);//处理完一个取一个
                channel.basicConsume("multiple" , false , new DefaultConsumer(channel){
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                        System.out.println("queue1:" + new String(body));

                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        channel.basicAck(envelope.getDeliveryTag() , false);
                    }
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        t1.start();

        Connection connection = Connect.getConnection();
        final Channel channel = connection.createChannel();

        //如果不写basicQos（1），则自动MQ会将所有请求平均发送给所有消费者
        //basicQos,MQ不再对消费者一次发送多个请求，而是消费者处理完一个消息后（确认后），在从队列中获取一个新的
        channel.basicQos(1);//处理完一个取一个
        channel.basicConsume("multiple" , false , new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("queue2:" + new String(body));

                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                channel.basicAck(envelope.getDeliveryTag() , false);
            }
        });
}
```

### 广播模式
```java
public static void main(String[] args) throws Exception {

        Map area = new LinkedHashMap<String, String>();
        area.put("msg.20201127", "msg.20201127");
        area.put("msg.20201128", "msg.20201128");
        area.put("msg.20201129", "msg.20201129");
        area.put("msg.20201130", "msg.20201130");

        area.put("msg.20201227", "msg.20201227");
        area.put("msg.20201228", "msg.20201228");
        area.put("msg.20201229", "msg.20201229");
        area.put("msg.20201230", "msg.20201230");


        Connection connection = Connect.getConnection();
        Channel channel = connection.createChannel();

        Iterator<Map.Entry<String, String>> itr = area.entrySet().iterator();
        while (itr.hasNext()) {
            Map.Entry<String, String> me = itr.next();
            channel.basicPublish("fanout","" , null , me.getValue().getBytes());

        }

        channel.close();
        connection.close();
}
```
```java
public static void main(String[] args) throws IOException {

        Thread t1 = new Thread(() -> {
            Connection connection = Connect.getConnection();
            //获取虚拟连接
            final Channel channel;
            try {
                channel = connection.createChannel();
                channel.queueDeclare("queue1", false, false, false, null);

                //queueBind用于将队列与交换机绑定
                //参数1：队列名 参数2：交互机名  参数三：路由key（暂时用不到)
                channel.queueBind("queue1", "fanout", "");
                channel.basicQos(1);
                channel.basicConsume("queue1" , false , new DefaultConsumer(channel){
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                        System.out.println("queue1:" + new String(body));
                        channel.basicAck(envelope.getDeliveryTag() , false);
                    }
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        t1.start();

        Connection connection = Connect.getConnection();
        //获取虚拟连接
        final Channel channel;
        try {
            channel = connection.createChannel();
            channel.queueDeclare("queue2", false, false, false, null);

            //queueBind用于将队列与交换机绑定
            //参数1：队列名 参数2：交互机名  参数三：路由key（暂时用不到)
            channel.queueBind("queue2", "fanout", "");
            channel.basicQos(1);
            channel.basicConsume("queue2" , false , new DefaultConsumer(channel){
                @Override
                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                    System.out.println("queue2:" + new String(body));
                    channel.basicAck(envelope.getDeliveryTag() , false);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

### 路由模式
```java
public static void main(String[] args) throws Exception {

        Map area = new LinkedHashMap<String, String>();
        area.put("msg.20201127", "msg.20201127");
        area.put("msg.20201128", "msg.20201128");
        area.put("msg.20201129", "msg.20201129");
        area.put("msg.20201130", "msg.20201130");

        area.put("msg.20201227", "msg.20201227");
        area.put("msg.20201228", "msg.20201228");
        area.put("msg.20201229", "msg.20201229");
        area.put("msg.20201230", "msg.20201230");


        Connection connection = Connect.getConnection();
        Channel channel = connection.createChannel();

        Iterator<Map.Entry<String, String>> itr = area.entrySet().iterator();
        while (itr.hasNext()) {
            Map.Entry<String, String> me = itr.next();
            channel.basicPublish("routing",me.getKey() , null , me.getValue().getBytes());

        }

        channel.close();
        connection.close();
}
```
```java
public static void main(String[] args) throws IOException {

        Thread t1 = new Thread(() -> {
            Connection connection = Connect.getConnection();
            //获取虚拟连接
            final Channel channel;
            try {
                channel = connection.createChannel();
                channel.queueDeclare("queue1", false, false, false, null);

                //queueBind用于将队列与交换机绑定
                //参数1：队列名 参数2：交互机名  参数三：路由key
                channel.queueBind("queue1", "routing", "msg.20201127");
                channel.queueBind("queue1", "routing", "msg.20201128");
                channel.basicQos(1);
                channel.basicConsume("queue1" , false , new DefaultConsumer(channel){
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                        System.out.println("queue1:" + new String(body));
                        channel.basicAck(envelope.getDeliveryTag() , false);
                    }
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        t1.start();

        Connection connection = Connect.getConnection();
        //获取虚拟连接
        final Channel channel;
        try {
            channel = connection.createChannel();
            channel.queueDeclare("queue2", false, false, false, null);

            //queueBind用于将队列与交换机绑定
            //参数1：队列名 参数2：交互机名  参数三：路由key
            channel.queueBind("queue2", "routing", "msg.20201227");
            channel.queueBind("queue2", "routing", "msg.20201228");
            channel.basicQos(1);
            channel.basicConsume("queue2" , false , new DefaultConsumer(channel){
                @Override
                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                    System.out.println("queue2:" + new String(body));
                    channel.basicAck(envelope.getDeliveryTag() , false);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

### 主题模式
```java
public static void main(String[] args) throws Exception {

        Map area = new LinkedHashMap<String, String>();
        area.put("msg.20201127", "msg.20201127");
        area.put("msg.20201128", "msg.20201128");
        area.put("msg.20201129", "msg.20201129");
        area.put("msg.20201130", "msg.20201130");

        area.put("msg.20201227", "msg.20201227");
        area.put("msg.20201228", "msg.20201228");
        area.put("msg.20201229", "msg.20201229");
        area.put("msg.20201230", "msg.20201230");


        Connection connection = Connect.getConnection();
        Channel channel = connection.createChannel();

        Iterator<Map.Entry<String, String>> itr = area.entrySet().iterator();
        while (itr.hasNext()) {
            Map.Entry<String, String> me = itr.next();
            channel.basicPublish("topic",me.getKey() , null , me.getValue().getBytes());

        }

        channel.close();
        connection.close();
}
```
```java
public static void main(String[] args) throws IOException {

        Thread t1 = new Thread(() -> {
            Connection connection = Connect.getConnection();
            //获取虚拟连接
            final Channel channel;
            try {
                channel = connection.createChannel();
                channel.queueDeclare("queue1", false, false, false, null);

                //queueBind用于将队列与交换机绑定
                //参数1：队列名 参数2：交互机名  参数三：路由key
                channel.queueBind("queue1", "topic", "*.20201127");
                channel.queueBind("queue1", "topic", "*.20201128");
                channel.basicQos(1);
                channel.basicConsume("queue1" , false , new DefaultConsumer(channel){
                    @Override
                    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                        System.out.println("queue1:" + new String(body));
                        channel.basicAck(envelope.getDeliveryTag() , false);
                    }
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        t1.start();

        Connection connection = Connect.getConnection();
        //获取虚拟连接
        final Channel channel;
        try {
            channel = connection.createChannel();
            channel.queueDeclare("queue2", false, false, false, null);

            //queueBind用于将队列与交换机绑定
            //参数1：队列名 参数2：交互机名  参数三：路由key
            channel.queueBind("queue2", "topic", "*.20201227");
            channel.queueBind("queue2", "topic", "*.20201228");
            channel.basicQos(1);
            channel.basicConsume("queue2" , false , new DefaultConsumer(channel){
                @Override
                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                    System.out.println("queue2:" + new String(body));
                    channel.basicAck(envelope.getDeliveryTag() , false);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

### 确认机制
```java
public static void main(String[] args) throws IOException, TimeoutException {

        Map area = new LinkedHashMap<String, String>();
        area.put("msg.20201127", "msg.20201127");
        area.put("msg.20201128", "msg.20201128");
        area.put("msg.20201129", "msg.20201129");
        area.put("msg.20201130", "msg.20201130");

        area.put("msg.20201227", "msg.20201227");
        area.put("msg.20201228", "msg.20201228");
        area.put("msg.20201229", "msg.20201229");
        area.put("msg.20201230", "msg.20201230");

        Connection connection = Connect.getConnection();
        Channel channel = connection.createChannel();
        //开启confirm监听模式
        channel.confirmSelect();
        channel.addConfirmListener(new ConfirmListener() {
            public void handleAck(long l, boolean b) throws IOException {
                //第二个参数代表接收的数据是否为批量接收，一般我们用不到。
                System.out.println("消息已被Broker接收,Tag:" + l );
            }

            public void handleNack(long l, boolean b) throws IOException {
                System.out.println("消息已被Broker拒收,Tag:" + l);
            }
        });
        channel.addReturnListener(new ReturnCallback() {
            public void handle(Return r) {
                System.err.println("===========================");
                System.err.println("Return编码：" + r.getReplyCode() + "-Return描述:" + r.getReplyText());
                System.err.println("交换机:" + r.getExchange() + "-路由key:" + r.getRoutingKey() );
                System.err.println("Return主题：" + new String(r.getBody()));
                System.err.println("===========================");
            }
        });
        Iterator<Map.Entry<String, String>> itr = area.entrySet().iterator();
        while (itr.hasNext()) {
            Map.Entry<String, String> me = itr.next();
            //Routing key 第二个参数相当于数据筛选的条件
            //第三个参数为：mandatory true代表如果消息无法正常投递则return回生产者，如果false，则直接将消息放弃。
            channel.basicPublish("confirm",me.getKey() ,true, null , me.getValue().getBytes());
        }

        //如果关闭则无法进行监听，因此此处不需要关闭
        /*channel.close();
        connection.close();*/
}
```

参考文献
--

图灵学院java架构课程