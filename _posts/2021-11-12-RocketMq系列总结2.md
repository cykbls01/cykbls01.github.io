---
layout:     post
title:      RocketMq系列总结2
subtitle:   RocketMq Demo
date:       2021-11-12
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - rocketmq
    - java

---


# RocketMq系列总结2

RocketMq 使用教程
--

---

## Maven配置

```java
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.9.2</version>
</dependency>
```
## 建立连接
```java
    private static DefaultMQProducer producer = new DefaultMQProducer("ProducerGroupName");
    private static DefaultMQPullConsumer pull = new DefaultMQPullConsumer("PullGroupName");
    private static DefaultMQPushConsumer push = new DefaultMQPushConsumer("PushGroupName");
    static {
        producer.setNamesrvAddr("192.168.2.11:9876");
        pull.setNamesrvAddr("192.168.2.11:9876");
        push.setNamesrvAddr("192.168.2.11:9876");
    }
    public static DefaultMQProducer getProducer(){
        try {
            return producer;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    public static DefaultMQPullConsumer getPull(){
        try {
            return pull;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    public static DefaultMQPushConsumer getPush(){
        try {
            return push;
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
```
## 消息类型

关于启动顺序，请优先启动带有队列声明的代码，之所以把队列声明不放在一个地方，主要是为了体会队列声明谁都可以进行，但是如果不先声明队列，消息无法直接或者从exchange到达。

同时请在rabbit管理界面优先创建三种对应模式的exchange。

### 同步发送/pull模式

使用sendoneway，可以直接发送而不用等待返回。

```java
public static void main(String[] args) throws MQClientException, InterruptedException, MQClientException {

        DefaultMQProducer producer = Connect.getProducer();
        producer.start();

        for (int i = 0; i < 20; i++)
            try {
                {
                    Message msg = new Message("pull",
                            "TagA",
                            "OrderID188",
                            "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));
                    
                    //同步传递消息，消息会发给集群中的一个Broker节点。
                    SendResult sendResult = producer.send(msg);
                    System.out.printf("%s%n", sendResult);
                    //使用该语句，可以不等待返回，直接发送
                    //producer.sendOneway(msg);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }

        producer.shutdown();
}
```
```java
    private static final Map<MessageQueue, Long> OFFSE_TABLE = new HashMap<MessageQueue, Long>();

public static void main(String[] args) throws MQClientException {
    
        DefaultMQPullConsumer consumer = Connect.getPull();
        consumer.start();

        Set<MessageQueue> mqs = consumer.fetchSubscribeMessageQueues("pull");
        for (MessageQueue mq : mqs) {
            System.out.printf("Consume from the queue: %s%n", mq);
            SINGLE_MQ:
            while (true) {
                try {
                    PullResult pullResult =
                            consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);
                    System.out.printf("%s%n", pullResult);
                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());
                    switch (pullResult.getPullStatus()) {
                        case FOUND:
                            break;
                        case NO_MATCHED_MSG:
                            break;
                        case NO_NEW_MSG:
                            break SINGLE_MQ;
                        case OFFSET_ILLEGAL:
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        consumer.shutdown();
}

    private static long getMessageQueueOffset(MessageQueue mq) {
        Long offset = OFFSE_TABLE.get(mq);
        if (offset != null)
            return offset;

        return 0;
    }

    private static void putMessageQueueOffset(MessageQueue mq, long offset) {
        OFFSE_TABLE.put(mq, offset);
    }

```

### 异步发送/push模式

通过设置延迟时间和消费模式，可以发送延迟消息以及进行广播消费。

```java
public static void main(String[] args) throws MQClientException, InterruptedException, UnsupportedEncodingException {

        DefaultMQProducer producer = Connect.getProducer();
        producer.start();
        producer.setRetryTimesWhenSendAsyncFailed(0);

        int messageCount = 10;
        //由于是异步发送，这里引入一个countDownLatch，保证所有Producer发送消息的回调方法都执行完了再停止Producer服务。
        final CountDownLatch countDownLatch = new CountDownLatch(messageCount);
        for (int i = 0; i < messageCount; i++) {
            try {
                final int index = i;
                Message msg = new Message("push",
                        "TagA",
                        "OrderID188",
                        "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));

                //启用该代码，使用延迟消息
                //msg.setDelayTimeLevel(3);
                producer.send(msg, new SendCallback() {
                    @Override
                    public void onSuccess(SendResult sendResult) {
                        countDownLatch.countDown();
                        System.out.printf("%-10d OK %s %n", index, sendResult.getMsgId());
                    }

                    @Override
                    public void onException(Throwable e) {
                        countDownLatch.countDown();
                        System.out.printf("%-10d Exception %s %n", index, e);
                        e.printStackTrace();
                    }
                });
                System.out.println("消息发送完成");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        countDownLatch.await(5, TimeUnit.SECONDS);
        producer.shutdown();
}
```
```java
public static void main(String[] args) throws InterruptedException, MQClientException{
    
        DefaultMQPushConsumer consumer = Connect.getPush();
        consumer.subscribe("push", "*");
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        //启用该行代码，采用广播模式消费
        //consumer.setMessageModel(MessageModel.BROADCASTING);
        consumer.setConsumeTimestamp("20181109221800");
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        consumer.start();
        System.out.printf("Consumer Started.%n");
}
```

### 顺序模式
```java
public static void main(String[] args) throws UnsupportedEncodingException {
    
        try {
            DefaultMQProducer producer = Connect.getProducer();
            producer.start();

            for (int i = 0; i < 10; i++) {
                int orderId = i;

                for(int j = 0 ; j <= 5 ; j ++){
                    Message msg =
                            new Message("order", "order_"+orderId, "KEY" + orderId,
                                    ("order_"+orderId+" step " + j).getBytes(RemotingHelper.DEFAULT_CHARSET));
                    SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
                        @Override
                        public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
                            Integer id = (Integer) arg;
                            int index = id % mqs.size();
                            return mqs.get(index);
                        }
                    }, orderId);

                    System.out.printf("%s%n", sendResult);
                }
            }

            producer.shutdown();
        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {
            e.printStackTrace();
        }
}
```
```java
public static void main(String[] args) throws MQClientException {
    
        DefaultMQPushConsumer consumer = Connect.getPush();
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);

        consumer.subscribe("order", "*");

        consumer.registerMessageListener(new MessageListenerOrderly() {
            @Override
            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {
                context.setAutoCommit(true);
                for(MessageExt msg:msgs){
                    System.out.println("收到消息内容 "+new String(msg.getBody()));
                }
                return ConsumeOrderlyStatus.SUCCESS;
            }
        });

        consumer.start();
        System.out.printf("Consumer Started.%n");
}
```

### 批量模式
```java
public static void main(String[] args) throws Exception {

        DefaultMQProducer producer = Connect.getProducer();
        producer.start();

        String topic = "batch";
        for (int i = 0; i < 10; i++) {
            List<Message> messages = new ArrayList<>(100);
            for(int j = 0; j < 100; j++){
                messages.add(new Message(topic, "Tag", "OrderID" + i, ("Hello world " + i).getBytes()));
            }
            producer.send(messages);
        }

        producer.shutdown();
}
```
```java
public static void main(String[] args) throws InterruptedException, MQClientException {
    
        DefaultMQPushConsumer consumer = Connect.getPush();
        consumer.subscribe("batch", "*");
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        //启用该行代码，采用广播模式消费
        //consumer.setMessageModel(MessageModel.BROADCASTING);
        consumer.setConsumeTimestamp("20181109221800");
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        consumer.start();
        System.out.printf("Consumer Started.%n");
}
```

### 过滤模式
```java
public static void main(String[] args) throws Exception {

        DefaultMQProducer producer = Connect.getProducer();
        producer.start();

        String[] tags = new String[] {"TagA", "TagB", "TagC"};

        for (int i = 0; i < 15; i++) {
            Message msg = new Message("filter",
                    tags[i % tags.length],
                    "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));

            SendResult sendResult = producer.send(msg);
            System.out.printf("%s%n", sendResult);
        }

        producer.shutdown();
}
```
```java
public static void main(String[] args) throws InterruptedException, MQClientException, IOException {

        DefaultMQPushConsumer consumer = Connect.getPush();

        consumer.subscribe("filter", "TagA || TagC");

        consumer.registerMessageListener(new MessageListenerConcurrently() {

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
                                                            ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });

        consumer.start();

        System.out.printf("Consumer Started.%n");
}
```



参考文献
--

图灵学院java架构课程