---
layout:     post
title:      RocketMq系列总结2
subtitle:   RocketMq Demo
date:       2021-11-10
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - rocketmq
    - java

---


# RocketMq系列总结2

RocketMq Demo
--

主要是介绍一下消费者和生产者的各类api以及配置，由maven进行简单配置。

---

## Maven配置

```java
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.7.1</version>
</dependency>
```
## 生产者实现

生产者的配置以及具体发送代码如下。发送消息主要有三种，同步异步以及直接发送。其中还可以设置消息的延迟时间以及批量发送。

```java
        DefaultMQProducer producer = new DefaultMQProducer("group_name");
        producer.setNamesrvAddr("192.168.2.11:9876");
        producer.start();//设置namesrc地址，启动生产者

        Message msg = new Message("topic_name","TagA","OrderID188","Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));//设置消息所属topic，tag名，key名以及消息内容
        
        //message.setDelayTimeLevel(3);//设置消息延迟时间

        /* 包含三种发送模式，同步，异步，直接发送
        producer.sendOneway(msg);//直接发送
        
        SendResult sendResult = producer.send(msg);//同步发送
        
        producer.send(msg, new SendCallback() {
                    @Override
                    public void onSuccess(SendResult sendResult) {
                        countDownLatch.countDown();
                        System.out.printf("%-10d OK %s %n", index,sendResult.getMsgId());
                    }

                    @Override
                    public void onException(Throwable e) {
                        countDownLatch.countDown();
                        System.out.printf("%-10d Exception %s %n", index, e);
                        e.printStackTrace();
                    }
                });
        Thread.sleep(1000);//异步发送，回调方法，使用sleep等待结果返回
        */

        /* 还可以使用批量发送，注意不要超过limit size
        List<Message> messages = new ArrayList<>();
        producer.send(messages);
        */
        
        
        producer.shutdown();//关闭生产者
```

## 消费者实现

消费者的配置以及具体接收代码如下。消费者消费模式包括pull和push模式，还可以以广播消息和过滤消息的模式进行消费。

```java
        
        DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("group_name");//pull模式
        consumer.setNamesrvAddr("192.168.2.11:9876");
        consumer.start();//设置namesrc地址，启动消费者
        Set<MessageQueue> mqs = consumer.fetchSubscribeMessageQueues("topic_name");
        for (MessageQueue mq : mqs) {
            SINGLE_MQ:
            while (true) {
                try {
                    PullResult pullResult = consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);
                    System.out.printf("%s%n", pullResult);
                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());
                    switch (pullResult.getPullStatus()) {
                        case FOUND:
                            break;
                        case NO_MATCHED_MSG:
                            break;
                        case NO_NEW_MSG:
                            break SINGLE_MQ;
                        case OFFSET_ILLEGAL:
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        consumer.shutdown();


        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group_name"); //push模式
        consumer.setNamesrvAddr("192.168.2.11:9876");
        //consumer.setMessageModel(MessageModel.BROADCASTING);//设置广播消费
        consumer.subscribe("topic_name", "*");
        //consumer.subscribe("TagFilterTest", "TagA || TagC");//设置tag便于过滤消息
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        consumer.registerMessageListener(new MessageListenerConcurrently() {

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        consumer.start();//启动之后不能关闭，否则无法监听消息

```

参考文献
--