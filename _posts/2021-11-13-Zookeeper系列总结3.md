---
layout:     post
title:      Zookeeper系列总结3
subtitle:   Zookeeper基础知识
date:       2021-11-13
author:     Yikun Chen
header-img: img/background/header.png
catalog: true
tags:
    - zookeeper

---


# Zookeeper系列总结3

Zookeeper基础知识
--

## 基本简介

Zookeeper是一个分布式协调框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。可以简单的理解为是一个用于存储少量数据的基于内存的数据库。

## 基本概念

### 文件系统结构

Zookeeper维护一个类似文件系统的数据结构，每个子目录项都被称作为 **znode(目录节点)**，和文件系统类似，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode。

节点类型

PERSISTENT-持久化目录节点。客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在

PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点。客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号

EPHEMERAL-临时目录节点。客户端与zookeeper断开连接后，该节点被删除

EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点。客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号

Container 节点（3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除,定时任务默认60s 检查一次） 

TTL 节点( 默认禁用，只能通过系统配置 *zookeeper.extendedTypesEnabled=true* 开启，不稳定)

![picture1](/img/zookeeper/filesystem.png)

### 监听通知机制

客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点 

1. 如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知

2. 如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知

3. 如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。

所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触发一次。

### 应用场景

1. 分布式配置中心

2. 分布式注册中心

3. 分布式锁

4. 分布式队列

5. 集群选举

6. 分布式屏障

7. 发布/订阅

## 持久化机制

### 事务日志

针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，当然，Zookeeper也会将数据变更应用到内存数据库中。我们可以在zookeeper的主配置文件zoo.cfg 中配置内存中的数据持久化目录，也就是事务日志的存储路径 dataLogDir. 如果没有配置dataLogDir（非必填）, 事务日志将存储到dataDir （必填项）目录。 

每条记录从左到右分别记录了操作时间，客户端会话ID，CXID,ZXID,操作类型，节点路径，节点数据（用#+ascii 码表示），节点版本。

Zookeeper进行事务日志文件操作的时候会频繁进行磁盘IO操作，事务日志的不断追加写操作会触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。因此，为了提升磁盘IO的效率，Zookeeper在创建事务日志文件的时候就进行文件空间的预分配- 即在创建文件的时候，就向操作系统申请一块大一点的磁盘块。这个预分配的磁盘大小可以通过系统参数 zookeeper.preAllocSize 进行配置。事务日志文件名为： log.<当时最大事务ID>，应为日志文件时顺序写入的，所以这个最大事务ID也将是整个事务日志文件中，最小的事务ID，日志满了即进行下一次事务日志文件的创建。

### 数据快照

数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。可以通过配置snapCount配置每间隔事务请求个数，生成快照，数据存储在dataDir 指定的目录中，快照事务日志文件名为： snapshot.<当时最大事务ID>，日志满了即进行下一次事务日志文件的创建。

二者区别是快照数据主要时为了快速恢复，事务日志文件是每次事务请求都会进行追加的操作，而快照是达到某种设定条件下的内存全量数据。所以通常快照数据是反应当时内存数据的状态。事务日志是更全面的数据，所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据即可。

## 相关应用

### 分布式锁

下图的实现方式在并发问题比较严重的情况下，性能会下降的比较厉害，主要原因是，所有的连接都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时收到事件，再次并发竞争，这就是**羊群效应**。这种加锁方式是**非公平锁**的具体实现。

![picture1](/img/zookeeper/lock.png)

下图借助于临时顺序节点，可以避免同时多个节点的并发竞争锁，缓解了服务端压力。这种实现方式所有加锁请求都进行排队加锁，是**公平锁**的具体实现。

![picture1](/img/zookeeper/fairlock.png)

下图的共享锁是针对读多写少的情况。数据在没有进行任何修改的话，是不需要加锁的，在读取数据的时候，给这个读请求加一个标识（读锁），让写请求知道，这个时候不能修改数据。在写数据的时候，再来一个请求写数据，是不允许的，这样也会导致数据的不一致，所以所有的写请求，都需要加一个写锁，是为了避免同时对共享数据进行写操作。

![picture1](/img/zookeeper/readlock.png) 

### 注册中心

![picture1](/img/zookeeper/register.png) 

使用Zookeeper的基本特性来实现一个注册中心，让众多的服务，都在Zookeeper中进行注册，把自己的一些服务信息，比如IP，端口，还有一些更加具体的服务信息，都写到 Zookeeper节点上， 这样有需要的服务就可以直接从zookeeper上面获取。 比如对于User-Service, 所有的**用户服务**在**启动**的时候，都在User-Service 这个节点下面创建一个子节点（临时节点），这个子节点保持唯一就好，代表了每个服务实例的唯一标识，有依赖**用户服务**的比如**Order-Service** 就可以通过**User-Service** 这个父节点，就能获取所有的User-Service 子节点，并且获取所有的子节点信息，拿到子节点的数据后**Order-Service**可以对其进行缓存，然后实现一个客户端的负载均衡，同时还可以对这个User-Service 目录进行监听， 这样有新的节点加入，或者退出，**Order-Service**都能收到通知，这样**Order-Service**重新获取所有子节点，且进行数据更新。这个用户服务的子节点的类型为临时节点。 当有新服务加入时，同样也会通知对应的客户端，刷新本地缓存，要达到这个目标需要客户端重复的注册对父节点的监听。这样就实现了服务的自动注册和自动退出。


参考文献
--

图灵学院java架构课程